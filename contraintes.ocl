-- Chaque noeud est identifié par 3 lettres
context NoeudTransport
    inv: self.code.size() = 3

-- Chaque Aéroport, Port, Gare possède un code unique respectivement.
context Aéroport
    inv: Aéroport.allInstances()->isUnique(code)

context Port
    inv: Port.allInstances()->isUnique(code)

context Gare
    inv: Gare.allInstances()->isUnique(code)

-- le noeud de depart et d'arrivé doit être différent
-- L'ID XX-1234..  XX est unique pour chaque companie, 1234.. est unique pour chaque itineraire dans le companie
context itineraire
    inv: self.depart <> self.arrive
    inv: self.id.substring(1, 2) = self.compagnie.prefixecompagnie 
    inv: self.compagnie.iteneraires->isUnique(id.substring(3, -1))

-- Tous les cabines/sièges d'une même section ont le même prix
-- Ceci est déjà renforcé de la facon le système est concu
context Section
    inv MemePrixPourTousLesSieges:
        self.sieges->forAll(s1, s2 |
            s1.t = s2.t
        )

-- Le port de départ et d'arrivée doit être le même
-- Une itineraire ne peut pas durer plus que 21 jours
context ItineraireCroisiere
    def: duree:Integer = self.DateHeureArrive - self.DateHeureDepart
    inv: self.depart = self.arrive
    inv: duree < 21 * 24 * 60 * 60; -- 21 jours en secondes, assumant "Time" est en secondes

    -- Un paquebot peut être assigné à plusieurs iténeraires tant qu'ils ne se chevauchent pas 
    -- J'assume qu'on peut le rephraser comme : deux itineraires dont leurs heures se croisent,
    -- ne peuvent pas avoir le même paquebot
    inv: self.compagnie.itineraires->forAll(i1, i2 |
        i1 <> i2 
        and
        i1.DateHeureDepart < i2.dateHeureArrive and
        i2.DateHeureDepart < i1.dateHeureArrive
        implies
        i1.paquebot <> i2.paquebot
    )

-- Le client peut reserver un siège disponible dans un vol donné
context ClientController::reserverUnite(IdItineraire:String, t:typeSection, p:Preference)
    pre SiegeDisponible:
        let itin : Itineraire =
            self.ItineraireCatalog.itineraires
                ->any(i | i.id = IdItineraire)
        in
        itin.avion.sections
            ->any(s | s.typeSection = t)
            .sieges
            ->exists(sg | sg.p = p and sg.disponible = true)
    
    post ReservationCree:
        result.unite.disponible = false and
        result.statut = StatutReservation::EN_ATTENTE and
        result.noReservation <> null

    body: 
        result.noReservation

-- Le client peut reserver une cabine disponible dans un itiniraireCroisiere donné
context ClientController::reserverUnite(IdItineraire:String, t:typeSection)
    pre SiegeDisponible:
        let itin : Itineraire =
            self.ItineraireCatalog.itineraires
                ->any(i | i.id = IdItineraire)
        in
        itin.paquebot.sections
            ->any(s | s.typeSection = t)
            .cabines
            ->exists(c | c.disponible = true)
    
    post ReservationCree:
        result.unite.disponible = false and
        result.statut = StatutReservation::EN_ATTENTE and
        result.noReservation <> null

    body: 
        result.noReservation

-- Un siege reservé devient assigné à un passager une fois payé
context ClientController::payerReservation(noReservation:int, nom:String, courriel:String, noPasseport:String, carteCredit:CarteCredit)
    pre ReservationValide:
        self.reservationCatalog.reservations
            ->exists(res |
                res.noReservation = noReservation and
                res.statut = StatutReservation::EN_ATTENTE
            )
    post ReservationConfirmee:
        let r : Reservation =
            self.reservationCatalog.reservations
                ->any(res | res.noReservation = noReservation)
        in
            r.statut = StatutReservation::CONFIRMEE and
            r.statut@pre = StatutReservation::EN_ATTENTE and
            r.unite.disponible = false